#!/usr/bin/env python
from os import listdir, statvfs
from os.path import normpath
from types import SimpleNamespace
from subprocess import Popen, PIPE
from io import TextIOWrapper
import sys

entries = {}

mounts_all = set()
mounts_mem = dict() # holds sum of PSS for every mmaped region of tmpfs-backed files
with open('/proc/mounts') as f:
	for line in f:
		_, mountpoint, type, _, _, _ = line.split()

		# FIXME? does anyone mmap() bind-mounted regular files?
		mountpoint = normpath(mountpoint)
		if mountpoint != '/':
			mountpoint += '/'

		mounts_all.add(mountpoint)

		if type in ('tmpfs', 'devtmpfs'):
			mounts_mem[mountpoint] = 0

			s = statvfs(mountpoint)
			size = (s.f_blocks - s.f_bfree) * s.f_bsize
			entries[mountpoint] = SimpleNamespace(
				size = size,
				accurate = True,
				pid = 'tmpfs',
				ppid = 1,
				name = mountpoint,
				children = [],
			)

mounts_all = sorted(mounts_all, key=len, reverse=True)

for p in listdir('/proc'):
	try: p = int(p)
	except: continue

	try:
		print(f'reading {p}...', end='\r')

		name = open('/proc/%d/cmdline' % p).read()
		for c in '\0\r\n\033':
			name = name.replace(c, ' ')
		if not name:
			# skip kernel thread
			continue
		ppid = None
		with open('/proc/%d/status' % p) as f:
			for line in f:
				if line.startswith('PPid:\t'):
					ppid = int(line[6:].rstrip('\n'))
					continue

		size = 0
		accurate = True
		mountpoint = None # temporary, per-region
		try:
			with open('/proc/%d/smaps' % p) as f:
				for line in f:
					line = line.split(None, 5)
					if ':' not in line[0]:
						'''
						assume region map header, like this one:
						7fbebe4b5000-7fbebe53c000 rw-s 00000000 00:2d 10701860    /dev/shm/... (deleted)

						line[5] should be the path since we limited split() to 5 splits
						'''
						mountpoint = None
						if len(line) < 6:
							# path can be absent
							pass
						else:
							path = line[5]
							for try_mountpoint in mounts_all:
								# XXX this does not work well with files opened before tmpfs was mounted on top of them,
								# and there's nothing we can do about it
								if path.startswith(try_mountpoint):
									mountpoint = try_mountpoint
									break
					if line[0] in ('Pss:', 'SwapPss:'):
						if line[2] == 'kB':
							amount = int(line[1]) * 1024
							size += amount
							if mountpoint in mounts_mem:
								mounts_mem[mountpoint] += amount
						else:
							accurate = False
		except PermissionError:
			accurate = False
	except FileNotFoundError:
		continue
	entries[p] = SimpleNamespace(
		size = size,
		accurate = accurate,
		pid = p,
		ppid = ppid,
		name = name,
		children = [],
	)

for mountpoint, amount in mounts_mem.items():
	entries[mountpoint].size -= amount

# build the tree
for e in entries.values():
	if e.pid == 1: continue
	entries[e.ppid].children.append(e)

def update_size_total(entry):
	for child in entry.children:
		update_size_total(child)
	entry.size_total = entry.size + sum(child.size_total for child in entry.children)
	entry.accurate_total = entry.accurate and all([child.accurate_total for child in entry.children])

update_size_total(entries[1])

# sort by size
for e in entries.values():
	e.children.sort(key = lambda e: e.size_total, reverse = True)

def pretty_num(n):
	for prefix in ' kMGTPE':
		if n < 1024:
			return '% 7.1f%s' % (n, prefix)
		n /= 1024

def show_subtree(entry, prefix_first='', prefix_rest=''):
	print('%s%s\033[0m %s%s\033[0m %s ' % (
		'\033[33m' if not entry.accurate else '',
		pretty_num(entry.size),
		'\033[33m' if not entry.accurate_total else '',
		pretty_num(entry.size_total),
		'% 6s' % entry.pid,
	), end='')
	print(prefix_first + entry.name)
	for child in entry.children[:-1]:
		show_subtree(child, prefix_rest + '├ ', prefix_rest + '│ ')
	if entry.children:
		show_subtree(entry.children[-1], prefix_rest + '└ ', prefix_rest + '  ')

pager = Popen(('less', '-RS'), stdin=PIPE)
sys.stdout = TextIOWrapper(pager.stdin)

print('\033[1m', end='')
print('% 8s % 8s % 6s %s' % (
	'PSS',
	'∑ PSS',
	'PID',
	'command or mount point'
))
print('\033[0m', end='')
show_subtree(entries[1])

sys.stdout.close()
pager.wait()
